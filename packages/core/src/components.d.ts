/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { TextareaChangeEventDetail } from "./components/input-textarea/input-textarea-interface";
import { SelectChangeEventDetail } from "./components/listbox/listbox-interface";
import { RadioGroupChangeEventDetail } from "./components/radio-group/radio-group-inteface";
export { TextareaChangeEventDetail } from "./components/input-textarea/input-textarea-interface";
export { SelectChangeEventDetail } from "./components/listbox/listbox-interface";
export { RadioGroupChangeEventDetail } from "./components/radio-group/radio-group-inteface";
export namespace Components {
    interface AnyBadge {
        /**
          * Inline style of the component.
         */
        "anyStyle": any;
        /**
          * Severity type of the badge.
         */
        "severity": string;
        /**
          * Size of the badge, valid options are "large" and "xlarge".
         */
        "size": string;
        /**
          * Style class of the component.
         */
        "styleClass": string;
        /**
          * Value to display inside the badge.
         */
        "value": string;
    }
    interface AnyBadgeOverlay {
        /**
          * Style class of the component.
         */
        "styleClass": string;
    }
    interface AnyButton {
        /**
          * Inline style of the element.
         */
        "anyStyle"?: any;
        /**
          * Value of the badge.
         */
        "badge": string;
        /**
          * Style class of the badge.
         */
        "badgeClass": string;
        /**
          * When present, it specifies that the component should be disabled.
         */
        "disabled": boolean;
        "getButtonRef": () => Promise<HTMLButtonElement>;
        /**
          * Name of the icon.
         */
        "icon": string;
        /**
          * Height of the icon
         */
        "iconHeight": number;
        /**
          * Position of the icon, valid values are "left" and "right".
         */
        "iconPos": "left" | "right" | "top" | "bottom";
        /**
          * Width of the icon
         */
        "iconWidth": number;
        /**
          * Text of the button.
         */
        "label": string;
        /**
          * Whether the button is in loading state.
         */
        "loading": boolean;
        /**
          * Icon to display in loading state.
         */
        "loadingIcon": string;
        /**
          * Style class of the icon element
         */
        "loadingIconStyleClass": string;
        /**
          * Style class of the element.
         */
        "styleClass": string;
        /**
          * Type of the button.
         */
        "type": "button" | "submit" | "reset";
    }
    /**
     * Checkbox is an extension to the standard checkbox element with theming.
     */
    interface AnyCheckbox {
        /**
          * Inline style of the component.
         */
        "anyStyle": any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * Allows to select a boolean value instead of multiple values.
         */
        "binary": boolean;
        /**
          * Icon class of the checkbox icon.
         */
        "checkboxIcon": string;
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled": boolean;
        /**
          * Focuses on the checkbox element.
         */
        "inputFocus": () => Promise<void>;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Label of the checkbox.
         */
        "label": string;
        /**
          * Style class of the label.
         */
        "labelStyleClass": string;
        /**
          * Name of the checkbox group.
         */
        "name": string;
        /**
          * When present, it specifies that the component cannot be edited.
         */
        "readonly": boolean;
        /**
          * Style class of the component.
         */
        "styleClass": any;
        /**
          * The value of the checkbox does not mean if it's checked or not, use the `checked` property for that.  The value of a checkbox is analogous to the value of an `<input type="checkbox">`, it's only used when the checkbox participates in a native `<form>`.
         */
        "value": any;
    }
    /**
     * Dropdown, also known as Select, is used to choose an item from a collection of options.
     */
    interface AnyDropdown {
        /**
          * Inline style of the element.
         */
        "anyStyle"?: any;
        /**
          * Index of the element in tabbing order.
         */
        "anyTabIndex"?: number;
        /**
          * Whether to automatically manage layering.
         */
        "autoZIndex"?: boolean;
        /**
          * Base zIndex value to use in layering.
         */
        "baseZIndex"?: string;
        /**
          * Icon class of the dropdown clear icon.
         */
        "clearIcon"?: string;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled": boolean;
        /**
          * Icon class of the dropdown icon.
         */
        "dropdownIcon"?: string;
        /**
          * When specified, displays a filter input at header.
         */
        "filter": boolean;
        /**
          * Transition options of the hide animation.
         */
        "hideAnimation"?: string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Name of the dropdown input.
         */
        "name": string;
        /**
          * Name of the label field of an option
         */
        "optionLabel": string;
        /**
          * Name of the value field of an option.
         */
        "optionValue": string;
        /**
          * An array of objects to display as the available options.
         */
        "options": any[];
        /**
          * Height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value.
         */
        "panelScrollHeight"?: string;
        /**
          * Default text to display when no option is selected.
         */
        "placeholder"?: string;
        /**
          * When present, it specifies that the element value cannot be changed.
         */
        "readonly": boolean;
        /**
          * Keyframe name the show animation.
         */
        "showAnimation"?: string;
        /**
          * When enabled, a clear icon is displayed to clear the value.
         */
        "showClear"?: boolean;
        /**
          * Value of the dropdown list.
         */
        "value"?: any;
        /**
          * When present, list virtual scroller is enabled.
         */
        "virtualScroll": boolean;
    }
    interface AnyInputNumber {
        /**
          * Text to display before the value.
         */
        "aPrefix": string;
        /**
          * Text to display after the value.
         */
        "aSuffix": string;
        /**
          * Title text of the input text.
         */
        "aTitle": string;
        /**
          * Determines whether the input field is empty.
         */
        "allowEmpty": boolean;
        /**
          * Used to indicate that user input is required on an element before a form can be submitted.
         */
        "anyAriaRequired": boolean;
        /**
          * Inline style of the component.
         */
        "anyStyle": any;
        /**
          * Specifies tab order of the element.
         */
        "anyTabIndex": string;
        /**
          * Used to define a string that autocomplete attribute the current element.
         */
        "autocomplete": string;
        /**
          * Layout of the buttons, valid values are "stacked" (default), "horizontal" and "vertical".
         */
        "buttonLayout": string;
        /**
          * The currency to use in currency formatting. Possible values are the ISO 4217 currency codes(https://www.currency-iso.org/en/home/tables/table-a1.html), such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB. There is no default value; if the style is "currency", the currency property must be provided.
         */
        "currency": string;
        /**
          * How to display the currency in currency formatting. Possible values are "symbol" to use a localized currency symbol such as €, ü"code" to use the ISO currency code, "name" to use a localized currency name such as "dollar"; the default is "symbol".
         */
        "currencyDisplay": string;
        /**
          * Style class of the decrement button.
         */
        "decrementButtonClass": string;
        /**
          * Style class of the decrement button.
         */
        "decrementButtonIcon": string;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled": boolean;
        /**
          * Whether to format the value.
         */
        "format": boolean;
        /**
          * Style class of the increment button.
         */
        "incrementButtonClass": string;
        /**
          * Style class of the increment button.
         */
        "incrementButtonIcon": string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Inline style of the input field.
         */
        "inputStyle": any;
        /**
          * Style class of the input field.
         */
        "inputStyleClass": string;
        /**
          * The class of input wrapper element
         */
        "inputWrapperClass": string;
        /**
          * Label of the component
         */
        "label": string;
        /**
          * Locale to be used in formatting.
         */
        "locale": string;
        /**
          * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit". See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation for details.
         */
        "localeMatcher": string;
        /**
          * Maximum boundary value.
         */
        "max": number;
        /**
          * The maximum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (https://www.currency-iso.org/en/home/tables/table-a1.html) (2 if the list doesn't provide that information).
         */
        "maxFractionDigits": number;
        /**
          * Maximum number of character allows in the input field.
         */
        "maxlength": number;
        /**
          * Mininum boundary value.
         */
        "min": number;
        /**
          * The minimum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (https://www.currency-iso.org/en/home/tables/table-a1.html) (2 if the list doesn't provide that information).
         */
        "minFractionDigits": number;
        /**
          * Defines the behavior of the component, valid values are "decimal" and "currency".
         */
        "mode": string;
        /**
          * Name of the component
         */
        "name": string;
        /**
          * Advisory information to display on input.
         */
        "placeholder": string;
        /**
          * When present, it specifies that an input field is read-only.
         */
        "readonly": boolean;
        /**
          * When present, it specifies that an input field is required.
         */
        "required": boolean;
        /**
          * Displays spinner buttons.
         */
        "showButtons": boolean;
        /**
          * Size of the input field.
         */
        "size": number;
        /**
          * Step factor to increment/decrement the value.
         */
        "step": number;
        /**
          * Style class of the component.
         */
        "styleClass": string;
        /**
          * Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.
         */
        "useGrouping": boolean;
        /**
          * Value of the component.
         */
        "value": string;
    }
    /**
     * InputSwitch is used to select a boolean value.
     */
    interface AnyInputSwitch {
        /**
          * Inline style of the component.
         */
        "anyStyle": any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
         */
        "ariaLabeledBy"?: string;
        /**
          * If `true`, the input-switch is selected.
         */
        "checked": boolean;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled": boolean;
        /**
          * Value in unchecked state.
         */
        "falseValue": any;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Name of the checkbox group.
         */
        "name": string;
        /**
          * When present, it specifies that the component cannot be edited.
         */
        "readonly": boolean;
        /**
          * Style class of the component.
         */
        "styleClass": any;
        /**
          * Value in checked state.
         */
        "trueValue": any;
    }
    /**
     * The InputText component is a wrapper to the HTML input element with custom styling and additional
     * functionality.
     */
    interface AnyInputText {
        /**
          * Title text of the input text.
         */
        "aTitle": string;
        /**
          * Used to indicate that user input is required on an element before a form can be submitted.
         */
        "anyAriaRequired": boolean;
        /**
          * Specifies tab order of the element.
         */
        "anyTabIndex": string;
        /**
          * Used to define a string that autocomplete attribute the current element.
         */
        "autocomplete": string;
        /**
          * When present, it specifies that the element should be disabled
         */
        "disabled": boolean;
        /**
          * When enabled, the label will have floating effect on input text focus
         */
        "floatLabel": boolean;
        /**
          * Retrieves a reference to the input element within the component.
          * @returns The input element, or null if not found.
          * @example const inputElement = await myComponent.getInputRef(); if (inputElement) {   // Do something with the input element   inputElement.focus(); }
         */
        "getInputRef": () => Promise<HTMLInputElement | null>;
        /**
          * Inline style of the element
         */
        "inputClass"?: string;
        /**
          * The class of input holder element
         */
        "inputHolderClass": string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Inline style of the element
         */
        "inputStyle"?: any;
        /**
          * The class of input wrapper element
         */
        "inputWrapperClass": string;
        /**
          * Label of the input text
         */
        "label": string;
        /**
          * The class of left icon wrapper element
         */
        "leftIconClass": string;
        /**
          * Maximum number of character allows in the input field.
         */
        "maxlength": number;
        /**
          * Name of the input text.
         */
        "name": string;
        /**
          * Default text to display when no value in input text
         */
        "placeholder": string;
        /**
          * When present, it specifies that the element value cannot be changed
         */
        "readonly": boolean;
        /**
          * When present, it specifies that an input field is required.
         */
        "required": boolean;
        /**
          * The class of right icon wrapper element
         */
        "rightIconClass": string;
        /**
          * Size of the input field.
         */
        "size": number;
        /**
          * Value of the input text
         */
        "value": string;
    }
    interface AnyInputTextarea {
        /**
          * When present, textarea size changes as being typed.
         */
        "autoResize": boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled": boolean;
        /**
          * When enabled, the label will have floating effect on input text focus
         */
        "floatLabel": boolean;
        /**
          * Returns the native `<textarea>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLTextAreaElement>;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * The class of input wrapper element
         */
        "inputWrapperClass": string;
        /**
          * Label of the input text
         */
        "label": string;
        /**
          * Name of the input text.
         */
        "name": string;
        /**
          * Default text to display when no value in input textarea
         */
        "placeholder": string;
        /**
          * When present, it specifies that the element value cannot be changed
         */
        "readonly": boolean;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * Sets blur on the native `textarea` in `ion-textarea`. Use this method instead of the global `textarea.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the native `textarea` in `ion-textarea`. Use this method instead of the global `textarea.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: "hard" | "soft" | "off";
    }
    interface AnyListbox {
        /**
          * Inline style of the element.
         */
        "anyStyle": any;
        /**
          * When specified, allows selecting items with checkboxes.
         */
        "checkbox": boolean;
        /**
          * A property to uniquely identify a value in options.
         */
        "dataKey": string;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled": boolean;
        /**
          * Text to display when filtering does not return any results. Defaults to global value in i18n translation configuration.
         */
        "emptyFilterMessage": string;
        /**
          * Text to display when there is no data. Defaults to global value in i18n translation configuration.
         */
        "emptyMessage": string;
        /**
          * When specified, displays a filter input at header.
         */
        "filter": boolean;
        /**
          * When filtering is enabled, filterBy decides which field or fields (comma separated) to search against.
         */
        "filterBy": string;
        /**
          * Locale to use in filtering. The default locale is the host environment's current locale.
         */
        "filterLocale": string;
        /**
          * Defines how the items are filtered, valid values are "contains" (default) "startsWith", "endsWith", "equals", "notEquals", "in", "lt", "lte", "gt" and "gte".
         */
        "filterMatchMode": string;
        /**
          * When specified, filter displays with this value.
         */
        "filterValue"?: string;
        /**
          * Whether to display options as grouped when nested options are provided.
         */
        "group": boolean;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Inline style of the list element.
         */
        "listStyle": any;
        /**
          * Defines how multiple items can be selected, when true metaKey needs to be pressed to select or unselect an item and when set to false selection of each item can be toggled individually. On touch enabled devices, metaKeySelection is turned off automatically.
         */
        "metaKeySelection": boolean;
        /**
          * When specified, allows selecting multiple values.
         */
        "multiple": boolean;
        /**
          * Name of the dropdown input.
         */
        "name": string;
        /**
          * Name of the disabled field of an option.
         */
        "optionDisabled": string;
        /**
          * Name of the options field of an option group.
         */
        "optionGroupChildren": string;
        /**
          * Name of the label field of an option.
         */
        "optionLabel": string;
        /**
          * Name of the value field of an option.
         */
        "optionValue": string;
        /**
          * An array of objects to display as the available options.
         */
        "options": any[];
        /**
          * When present, it specifies that the element value cannot be changed.
         */
        "readonly": boolean;
        /**
          * Max height of the content area in inline mode.
         */
        "scrollerHeight": string;
        /**
          * Icon class of the filter search input icon.
         */
        "searchIcon"?: string;
        /**
          * Sets focus on the native `textarea` in `ion-textarea`. Use this method instead of the global `textarea.focus()`.
         */
        "setFilterInputFocus": () => Promise<void>;
        /**
          * Whether header checkbox is shown in multiple mode.
         */
        "showToggleAll": boolean;
        /**
          * Value of the listbox.
         */
        "value"?: any;
        /**
          * When present, list virtual scroller is enabled.
         */
        "virtualScroll": boolean;
    }
    interface AnyMultiselect {
        /**
          * Inline style of the element
         */
        "anyStyle"?: any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * When specified, allows selecting items with checkboxes
         */
        "checkbox": boolean;
        /**
          * Icon class of the dropdown clear icon
         */
        "clearIcon"?: string;
        /**
          * A property to uniquely identify a value in options
         */
        "dataKey": string;
        /**
          * When specified, allows selecting items with checkboxes
         */
        "defaultLabel": string;
        /**
          * When present, it specifies that the element should be disabled
         */
        "disabled": boolean;
        /**
          * Icon class of the dropdown icon
         */
        "dropdownIcon"?: string;
        /**
          * When specified, displays a filter input at header
         */
        "filter": boolean;
        /**
          * Whether to display options as grouped when nested options are provided
         */
        "group": boolean;
        /**
          * Transition options for the hide animation.
         */
        "hideAnimation"?: string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Name of the dropdown input.
         */
        "name": string;
        /**
          * Name of the options field of an option group.
         */
        "optionGroupChildren": string;
        /**
          * Name of the label field of an option
         */
        "optionLabel": string;
        /**
          * Name of the value field of an option
         */
        "optionValue": string;
        /**
          * An array of objects to display as the available options.
         */
        "options": any[];
        /**
          * Height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value
         */
        "panelScrollHeight"?: string;
        /**
          * Default text to display when no option is selected
         */
        "placeholder"?: string;
        /**
          * When present, it specifies that the element value cannot be changed
         */
        "readonly": boolean;
        /**
          * Keyframe name for the show animation.
         */
        "showAnimation"?: string;
        /**
          * When enabled, a clear icon is displayed to clear the value
         */
        "showClear"?: boolean;
        /**
          * Whether header checkbox is shown in multiple mode
         */
        "showToggleAll": boolean;
        /**
          * Value of the dropdown list
         */
        "value"?: any;
        /**
          * When present, list virtual scroller is enabled
         */
        "virtualScroll": boolean;
    }
    interface AnyOverlay {
        /**
          * Whether to automatically manage layering
         */
        "autoZIndex"?: boolean;
        /**
          * Base zIndex value to use in layering
         */
        "baseZIndex"?: string;
        /**
          * Transition options for the hide animation.
         */
        "hideAnimation"?: string;
        /**
          * Keyframe name for the show animation.
         */
        "showAnimation"?: string;
        /**
          * The target element to attach the dropdown to.
         */
        "target": any;
        /**
          * Whether the dropdown is currently visible or hidden.
         */
        "visible": boolean;
    }
    interface AnyRadioButton {
        /**
          * Inline style of the component.
         */
        "anyStyle": any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled": boolean;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId": string;
        /**
          * Label of the radiobutton.
         */
        "label": string;
        /**
          * Style class of the label.
         */
        "labelStyleClass": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Applies focus.
         */
        "setFocus": (ev: any) => Promise<void>;
        /**
          * Style class of the component.
         */
        "styleClass": any;
        /**
          * the value of the radio.
         */
        "value"?: any | null;
    }
    interface AnyRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection": boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface AnyRippleEffect {
        /**
          * Inline style of the component.
         */
        "anyStyle": any;
        /**
          * Sets the type of ripple-effect:
         */
        "type": "bounded" | "unbounded";
    }
    interface AnyTabPanel {
        /**
          * When true, tab cannot be activated.
         */
        "disabled": boolean;
        /**
          * Title of the tabPanel.
         */
        "header": string;
        /**
          * Defines if tab is active.
         */
        "selected": boolean;
    }
    interface AnyTabView {
        /**
          * Index of the active tab to change selected tab programmatically.
         */
        "activeIndex": number;
        /**
          * Inline style of the component.
         */
        "anyStyle": any;
        /**
          * Style class of the component.
         */
        "styleClass": string;
    }
    interface AnyVirtualScroller {
        /**
          * Inline style of the component
         */
        "anyStyle": any;
        /**
          * Class name of the content element where items will be rendered
         */
        "contentElemClass": string;
        /**
          * Tag name of content element whwre items will be rendered
         */
        "contentElemTag": string;
        /**
          * Threshold in milliseconds to delay lazy loading during scrolling
         */
        "delay": number;
        /**
          * Class name of the item element
         */
        "itemElemClass": string;
        /**
          * Height of an item in the list
         */
        "itemSize": number;
        /**
          * Tag name for supporting elements: spacing extra rows, empty-data row. It will be determined by itself once data provided, so it's optional. But if your data is not provided during initialization - it is better to specify this option because otherwise plugin will be unable to correctly render empty-data row.
         */
        "itemTag": string;
        /**
          * An array of objects to display
         */
        "items": any[];
        /**
          * Defines if data is loaded and interacted with in lazy manner
         */
        "lazy": boolean;
        /**
          * Text for placeholder element if there is no data provided
         */
        "noDataText": string;
        /**
          * Number of rows to display per page
         */
        "rowsPerPage": number;
        /**
          * Class name of the scroll element
         */
        "scrollElemClass": string;
        /**
          * Max height of the content area in inline mode
         */
        "scrollerHeight": any;
        /**
          * Inline style of the component
         */
        "styleClass": string;
    }
    interface AppCode {
        "code": any;
        "extFiles": any[];
        "hideCodeSandbox": boolean;
        "hideStackBlitz": boolean;
        "hideToggleCode": boolean;
        "routeFiles": any[];
        "selector": string;
        "service": any;
    }
    interface AppConfig {
    }
    interface AppDoc {
        "apiDocs": string[];
        "description": string;
        "docTitle": string;
        "docs": any[];
        "githubPage": string;
        "header": string;
    }
    interface AppDocapisection {
        "docs": any;
        "header": string;
    }
    interface AppDocapitable {
        "anyId": string;
        "data": any[];
        "description": string;
        "isInterface": boolean;
        "label": string;
        "level": number;
        "parentDescription": string;
        "parentId": string;
        "parentTitle": string;
        "relatedProp": string;
    }
    interface AppDocsection {
        "apiDocs"?: any[];
        "docs"?: any[];
    }
    interface AppDocsectionNav {
        "docs": any[];
    }
    interface AppDocsectiontext {
        "label": string;
        "level": number;
        "parentDescription": string;
        "parentId": string;
        "parentTitle": string;
        "textId": string;
        "textTitle": string;
    }
    interface CheckboxBasic {
        "textId": string;
        "textTitle": string;
    }
    interface CheckboxDisabled {
        "textId": string;
        "textTitle": string;
    }
    interface CheckboxDynamic {
        "textId": string;
        "textTitle": string;
    }
    interface CheckboxGroup {
        "textId": string;
        "textTitle": string;
    }
    interface CheckboxLabel {
        "textId": string;
        "textTitle": string;
    }
    interface CheckboxReadonly {
        "textId": string;
        "textTitle": string;
    }
    interface DropdownBasic {
        "textId": string;
        "textTitle": string;
    }
    interface DropdownDisabled {
        "textId": string;
        "textTitle": string;
    }
    interface DropdownFilter {
        "textId": string;
        "textTitle": string;
    }
    interface DropdownTemplate {
        "textId": string;
        "textTitle": string;
    }
    interface DropdownVirtualScroll {
        "textId": string;
        "textTitle": string;
    }
    interface InputSwitchBasic {
        "textId": string;
        "textTitle": string;
    }
    interface InputSwitchDisabled {
        "textId": string;
        "textTitle": string;
    }
    interface InputSwitchPreselection {
        "textId": string;
        "textTitle": string;
    }
    interface InputTextBasic {
        "textId": string;
        "textTitle": string;
    }
    interface InputTextDisabled {
        "textId": string;
        "textTitle": string;
    }
    interface InputTextFloatLabel {
        "textId": string;
        "textTitle": string;
    }
    interface InputTextIcons {
        "textId": string;
        "textTitle": string;
    }
}
export interface AnyButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyButtonElement;
}
export interface AnyCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyCheckboxElement;
}
export interface AnyDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyDropdownElement;
}
export interface AnyInputNumberCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyInputNumberElement;
}
export interface AnyInputSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyInputSwitchElement;
}
export interface AnyInputTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyInputTextElement;
}
export interface AnyInputTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyInputTextareaElement;
}
export interface AnyListboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyListboxElement;
}
export interface AnyMultiselectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyMultiselectElement;
}
export interface AnyOverlayCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyOverlayElement;
}
export interface AnyRadioButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyRadioButtonElement;
}
export interface AnyRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyRadioGroupElement;
}
export interface AnyVirtualScrollerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAnyVirtualScrollerElement;
}
export interface CheckboxBasicCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCheckboxBasicElement;
}
export interface CheckboxDisabledCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCheckboxDisabledElement;
}
export interface CheckboxDynamicCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCheckboxDynamicElement;
}
export interface CheckboxGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCheckboxGroupElement;
}
export interface CheckboxLabelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCheckboxLabelElement;
}
export interface CheckboxReadonlyCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCheckboxReadonlyElement;
}
declare global {
    interface HTMLAnyBadgeElement extends Components.AnyBadge, HTMLStencilElement {
    }
    var HTMLAnyBadgeElement: {
        prototype: HTMLAnyBadgeElement;
        new (): HTMLAnyBadgeElement;
    };
    interface HTMLAnyBadgeOverlayElement extends Components.AnyBadgeOverlay, HTMLStencilElement {
    }
    var HTMLAnyBadgeOverlayElement: {
        prototype: HTMLAnyBadgeOverlayElement;
        new (): HTMLAnyBadgeOverlayElement;
    };
    interface HTMLAnyButtonElementEventMap {
        "aOnClick": any;
        "aOnFocus": any;
        "aOnBlur": any;
    }
    interface HTMLAnyButtonElement extends Components.AnyButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyButtonElementEventMap>(type: K, listener: (this: HTMLAnyButtonElement, ev: AnyButtonCustomEvent<HTMLAnyButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyButtonElementEventMap>(type: K, listener: (this: HTMLAnyButtonElement, ev: AnyButtonCustomEvent<HTMLAnyButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyButtonElement: {
        prototype: HTMLAnyButtonElement;
        new (): HTMLAnyButtonElement;
    };
    interface HTMLAnyCheckboxElementEventMap {
        "valueChange": any;
        "aOnFocus": any;
        "aOnBlur": any;
    }
    /**
     * Checkbox is an extension to the standard checkbox element with theming.
     */
    interface HTMLAnyCheckboxElement extends Components.AnyCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyCheckboxElementEventMap>(type: K, listener: (this: HTMLAnyCheckboxElement, ev: AnyCheckboxCustomEvent<HTMLAnyCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyCheckboxElementEventMap>(type: K, listener: (this: HTMLAnyCheckboxElement, ev: AnyCheckboxCustomEvent<HTMLAnyCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyCheckboxElement: {
        prototype: HTMLAnyCheckboxElement;
        new (): HTMLAnyCheckboxElement;
    };
    interface HTMLAnyDropdownElementEventMap {
        "valueChange": any;
        "aOnPanelShow": any;
        "aOnPanelShowStart": any;
        "aOnPanelHide": any;
        "aOnPanelHideStart": any;
        "aOnFocus": any;
        "aOnBlur": any;
        "aOnClick": any;
    }
    /**
     * Dropdown, also known as Select, is used to choose an item from a collection of options.
     */
    interface HTMLAnyDropdownElement extends Components.AnyDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyDropdownElementEventMap>(type: K, listener: (this: HTMLAnyDropdownElement, ev: AnyDropdownCustomEvent<HTMLAnyDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyDropdownElementEventMap>(type: K, listener: (this: HTMLAnyDropdownElement, ev: AnyDropdownCustomEvent<HTMLAnyDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyDropdownElement: {
        prototype: HTMLAnyDropdownElement;
        new (): HTMLAnyDropdownElement;
    };
    interface HTMLAnyInputNumberElementEventMap {
        "aOnInput": any;
        "aOnFocus": any;
        "aOnBlur": any;
        "aOnKeyDown": any;
        "valueChange": any;
    }
    interface HTMLAnyInputNumberElement extends Components.AnyInputNumber, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyInputNumberElementEventMap>(type: K, listener: (this: HTMLAnyInputNumberElement, ev: AnyInputNumberCustomEvent<HTMLAnyInputNumberElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyInputNumberElementEventMap>(type: K, listener: (this: HTMLAnyInputNumberElement, ev: AnyInputNumberCustomEvent<HTMLAnyInputNumberElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyInputNumberElement: {
        prototype: HTMLAnyInputNumberElement;
        new (): HTMLAnyInputNumberElement;
    };
    interface HTMLAnyInputSwitchElementEventMap {
        "valueChange": any;
        "aOnFocus": any;
        "aOnBlur": any;
    }
    /**
     * InputSwitch is used to select a boolean value.
     */
    interface HTMLAnyInputSwitchElement extends Components.AnyInputSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyInputSwitchElementEventMap>(type: K, listener: (this: HTMLAnyInputSwitchElement, ev: AnyInputSwitchCustomEvent<HTMLAnyInputSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyInputSwitchElementEventMap>(type: K, listener: (this: HTMLAnyInputSwitchElement, ev: AnyInputSwitchCustomEvent<HTMLAnyInputSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyInputSwitchElement: {
        prototype: HTMLAnyInputSwitchElement;
        new (): HTMLAnyInputSwitchElement;
    };
    interface HTMLAnyInputTextElementEventMap {
        "valueChange": any;
    }
    /**
     * The InputText component is a wrapper to the HTML input element with custom styling and additional
     * functionality.
     */
    interface HTMLAnyInputTextElement extends Components.AnyInputText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyInputTextElementEventMap>(type: K, listener: (this: HTMLAnyInputTextElement, ev: AnyInputTextCustomEvent<HTMLAnyInputTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyInputTextElementEventMap>(type: K, listener: (this: HTMLAnyInputTextElement, ev: AnyInputTextCustomEvent<HTMLAnyInputTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyInputTextElement: {
        prototype: HTMLAnyInputTextElement;
        new (): HTMLAnyInputTextElement;
    };
    interface HTMLAnyInputTextareaElementEventMap {
        "aOnBlur": FocusEvent;
        "aOnFocus": FocusEvent;
        "aOnResize": any;
        "aOnInput": InputEvent;
        "valueChange": TextareaChangeEventDetail;
    }
    interface HTMLAnyInputTextareaElement extends Components.AnyInputTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyInputTextareaElementEventMap>(type: K, listener: (this: HTMLAnyInputTextareaElement, ev: AnyInputTextareaCustomEvent<HTMLAnyInputTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyInputTextareaElementEventMap>(type: K, listener: (this: HTMLAnyInputTextareaElement, ev: AnyInputTextareaCustomEvent<HTMLAnyInputTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyInputTextareaElement: {
        prototype: HTMLAnyInputTextareaElement;
        new (): HTMLAnyInputTextareaElement;
    };
    interface HTMLAnyListboxElementEventMap {
        "valueChange": SelectChangeEventDetail;
    }
    interface HTMLAnyListboxElement extends Components.AnyListbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyListboxElementEventMap>(type: K, listener: (this: HTMLAnyListboxElement, ev: AnyListboxCustomEvent<HTMLAnyListboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyListboxElementEventMap>(type: K, listener: (this: HTMLAnyListboxElement, ev: AnyListboxCustomEvent<HTMLAnyListboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyListboxElement: {
        prototype: HTMLAnyListboxElement;
        new (): HTMLAnyListboxElement;
    };
    interface HTMLAnyMultiselectElementEventMap {
        "valueChange": any;
        "aOnPanelShow": any;
        "aOnPanelShowStart": any;
        "aOnPanelHide": any;
        "aOnPanelHideStart": any;
        "aOnFocus": any;
        "aOnBlur": any;
        "aOnClick": any;
    }
    interface HTMLAnyMultiselectElement extends Components.AnyMultiselect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyMultiselectElementEventMap>(type: K, listener: (this: HTMLAnyMultiselectElement, ev: AnyMultiselectCustomEvent<HTMLAnyMultiselectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyMultiselectElementEventMap>(type: K, listener: (this: HTMLAnyMultiselectElement, ev: AnyMultiselectCustomEvent<HTMLAnyMultiselectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyMultiselectElement: {
        prototype: HTMLAnyMultiselectElement;
        new (): HTMLAnyMultiselectElement;
    };
    interface HTMLAnyOverlayElementEventMap {
        "aOnShow": any;
        "aOnShowStart": any;
        "aOnHide": any;
        "aOnHideStart": any;
    }
    interface HTMLAnyOverlayElement extends Components.AnyOverlay, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyOverlayElementEventMap>(type: K, listener: (this: HTMLAnyOverlayElement, ev: AnyOverlayCustomEvent<HTMLAnyOverlayElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyOverlayElementEventMap>(type: K, listener: (this: HTMLAnyOverlayElement, ev: AnyOverlayCustomEvent<HTMLAnyOverlayElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyOverlayElement: {
        prototype: HTMLAnyOverlayElement;
        new (): HTMLAnyOverlayElement;
    };
    interface HTMLAnyRadioButtonElementEventMap {
        "aOnSelect": any;
        "aOnFocus": any;
        "aOnBlur": any;
    }
    interface HTMLAnyRadioButtonElement extends Components.AnyRadioButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyRadioButtonElementEventMap>(type: K, listener: (this: HTMLAnyRadioButtonElement, ev: AnyRadioButtonCustomEvent<HTMLAnyRadioButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyRadioButtonElementEventMap>(type: K, listener: (this: HTMLAnyRadioButtonElement, ev: AnyRadioButtonCustomEvent<HTMLAnyRadioButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyRadioButtonElement: {
        prototype: HTMLAnyRadioButtonElement;
        new (): HTMLAnyRadioButtonElement;
    };
    interface HTMLAnyRadioGroupElementEventMap {
        "valueChange": RadioGroupChangeEventDetail;
    }
    interface HTMLAnyRadioGroupElement extends Components.AnyRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyRadioGroupElementEventMap>(type: K, listener: (this: HTMLAnyRadioGroupElement, ev: AnyRadioGroupCustomEvent<HTMLAnyRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyRadioGroupElementEventMap>(type: K, listener: (this: HTMLAnyRadioGroupElement, ev: AnyRadioGroupCustomEvent<HTMLAnyRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyRadioGroupElement: {
        prototype: HTMLAnyRadioGroupElement;
        new (): HTMLAnyRadioGroupElement;
    };
    interface HTMLAnyRippleEffectElement extends Components.AnyRippleEffect, HTMLStencilElement {
    }
    var HTMLAnyRippleEffectElement: {
        prototype: HTMLAnyRippleEffectElement;
        new (): HTMLAnyRippleEffectElement;
    };
    interface HTMLAnyTabPanelElement extends Components.AnyTabPanel, HTMLStencilElement {
    }
    var HTMLAnyTabPanelElement: {
        prototype: HTMLAnyTabPanelElement;
        new (): HTMLAnyTabPanelElement;
    };
    interface HTMLAnyTabViewElement extends Components.AnyTabView, HTMLStencilElement {
    }
    var HTMLAnyTabViewElement: {
        prototype: HTMLAnyTabViewElement;
        new (): HTMLAnyTabViewElement;
    };
    interface HTMLAnyVirtualScrollerElementEventMap {
        "scrollingProgress": any;
        "clusterChanged": any;
        "clusterWillChange": any;
        "aOnLazyLoad": any;
        "aOnItemClick": any;
    }
    interface HTMLAnyVirtualScrollerElement extends Components.AnyVirtualScroller, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAnyVirtualScrollerElementEventMap>(type: K, listener: (this: HTMLAnyVirtualScrollerElement, ev: AnyVirtualScrollerCustomEvent<HTMLAnyVirtualScrollerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAnyVirtualScrollerElementEventMap>(type: K, listener: (this: HTMLAnyVirtualScrollerElement, ev: AnyVirtualScrollerCustomEvent<HTMLAnyVirtualScrollerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAnyVirtualScrollerElement: {
        prototype: HTMLAnyVirtualScrollerElement;
        new (): HTMLAnyVirtualScrollerElement;
    };
    interface HTMLAppCodeElement extends Components.AppCode, HTMLStencilElement {
    }
    var HTMLAppCodeElement: {
        prototype: HTMLAppCodeElement;
        new (): HTMLAppCodeElement;
    };
    interface HTMLAppConfigElement extends Components.AppConfig, HTMLStencilElement {
    }
    var HTMLAppConfigElement: {
        prototype: HTMLAppConfigElement;
        new (): HTMLAppConfigElement;
    };
    interface HTMLAppDocElement extends Components.AppDoc, HTMLStencilElement {
    }
    var HTMLAppDocElement: {
        prototype: HTMLAppDocElement;
        new (): HTMLAppDocElement;
    };
    interface HTMLAppDocapisectionElement extends Components.AppDocapisection, HTMLStencilElement {
    }
    var HTMLAppDocapisectionElement: {
        prototype: HTMLAppDocapisectionElement;
        new (): HTMLAppDocapisectionElement;
    };
    interface HTMLAppDocapitableElement extends Components.AppDocapitable, HTMLStencilElement {
    }
    var HTMLAppDocapitableElement: {
        prototype: HTMLAppDocapitableElement;
        new (): HTMLAppDocapitableElement;
    };
    interface HTMLAppDocsectionElement extends Components.AppDocsection, HTMLStencilElement {
    }
    var HTMLAppDocsectionElement: {
        prototype: HTMLAppDocsectionElement;
        new (): HTMLAppDocsectionElement;
    };
    interface HTMLAppDocsectionNavElement extends Components.AppDocsectionNav, HTMLStencilElement {
    }
    var HTMLAppDocsectionNavElement: {
        prototype: HTMLAppDocsectionNavElement;
        new (): HTMLAppDocsectionNavElement;
    };
    interface HTMLAppDocsectiontextElement extends Components.AppDocsectiontext, HTMLStencilElement {
    }
    var HTMLAppDocsectiontextElement: {
        prototype: HTMLAppDocsectiontextElement;
        new (): HTMLAppDocsectiontextElement;
    };
    interface HTMLCheckboxBasicElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLCheckboxBasicElement extends Components.CheckboxBasic, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCheckboxBasicElementEventMap>(type: K, listener: (this: HTMLCheckboxBasicElement, ev: CheckboxBasicCustomEvent<HTMLCheckboxBasicElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCheckboxBasicElementEventMap>(type: K, listener: (this: HTMLCheckboxBasicElement, ev: CheckboxBasicCustomEvent<HTMLCheckboxBasicElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCheckboxBasicElement: {
        prototype: HTMLCheckboxBasicElement;
        new (): HTMLCheckboxBasicElement;
    };
    interface HTMLCheckboxDisabledElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLCheckboxDisabledElement extends Components.CheckboxDisabled, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCheckboxDisabledElementEventMap>(type: K, listener: (this: HTMLCheckboxDisabledElement, ev: CheckboxDisabledCustomEvent<HTMLCheckboxDisabledElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCheckboxDisabledElementEventMap>(type: K, listener: (this: HTMLCheckboxDisabledElement, ev: CheckboxDisabledCustomEvent<HTMLCheckboxDisabledElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCheckboxDisabledElement: {
        prototype: HTMLCheckboxDisabledElement;
        new (): HTMLCheckboxDisabledElement;
    };
    interface HTMLCheckboxDynamicElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLCheckboxDynamicElement extends Components.CheckboxDynamic, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCheckboxDynamicElementEventMap>(type: K, listener: (this: HTMLCheckboxDynamicElement, ev: CheckboxDynamicCustomEvent<HTMLCheckboxDynamicElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCheckboxDynamicElementEventMap>(type: K, listener: (this: HTMLCheckboxDynamicElement, ev: CheckboxDynamicCustomEvent<HTMLCheckboxDynamicElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCheckboxDynamicElement: {
        prototype: HTMLCheckboxDynamicElement;
        new (): HTMLCheckboxDynamicElement;
    };
    interface HTMLCheckboxGroupElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLCheckboxGroupElement extends Components.CheckboxGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLCheckboxGroupElement, ev: CheckboxGroupCustomEvent<HTMLCheckboxGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLCheckboxGroupElement, ev: CheckboxGroupCustomEvent<HTMLCheckboxGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCheckboxGroupElement: {
        prototype: HTMLCheckboxGroupElement;
        new (): HTMLCheckboxGroupElement;
    };
    interface HTMLCheckboxLabelElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLCheckboxLabelElement extends Components.CheckboxLabel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCheckboxLabelElementEventMap>(type: K, listener: (this: HTMLCheckboxLabelElement, ev: CheckboxLabelCustomEvent<HTMLCheckboxLabelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCheckboxLabelElementEventMap>(type: K, listener: (this: HTMLCheckboxLabelElement, ev: CheckboxLabelCustomEvent<HTMLCheckboxLabelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCheckboxLabelElement: {
        prototype: HTMLCheckboxLabelElement;
        new (): HTMLCheckboxLabelElement;
    };
    interface HTMLCheckboxReadonlyElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLCheckboxReadonlyElement extends Components.CheckboxReadonly, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCheckboxReadonlyElementEventMap>(type: K, listener: (this: HTMLCheckboxReadonlyElement, ev: CheckboxReadonlyCustomEvent<HTMLCheckboxReadonlyElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCheckboxReadonlyElementEventMap>(type: K, listener: (this: HTMLCheckboxReadonlyElement, ev: CheckboxReadonlyCustomEvent<HTMLCheckboxReadonlyElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCheckboxReadonlyElement: {
        prototype: HTMLCheckboxReadonlyElement;
        new (): HTMLCheckboxReadonlyElement;
    };
    interface HTMLDropdownBasicElement extends Components.DropdownBasic, HTMLStencilElement {
    }
    var HTMLDropdownBasicElement: {
        prototype: HTMLDropdownBasicElement;
        new (): HTMLDropdownBasicElement;
    };
    interface HTMLDropdownDisabledElement extends Components.DropdownDisabled, HTMLStencilElement {
    }
    var HTMLDropdownDisabledElement: {
        prototype: HTMLDropdownDisabledElement;
        new (): HTMLDropdownDisabledElement;
    };
    interface HTMLDropdownFilterElement extends Components.DropdownFilter, HTMLStencilElement {
    }
    var HTMLDropdownFilterElement: {
        prototype: HTMLDropdownFilterElement;
        new (): HTMLDropdownFilterElement;
    };
    interface HTMLDropdownTemplateElement extends Components.DropdownTemplate, HTMLStencilElement {
    }
    var HTMLDropdownTemplateElement: {
        prototype: HTMLDropdownTemplateElement;
        new (): HTMLDropdownTemplateElement;
    };
    interface HTMLDropdownVirtualScrollElement extends Components.DropdownVirtualScroll, HTMLStencilElement {
    }
    var HTMLDropdownVirtualScrollElement: {
        prototype: HTMLDropdownVirtualScrollElement;
        new (): HTMLDropdownVirtualScrollElement;
    };
    interface HTMLInputSwitchBasicElement extends Components.InputSwitchBasic, HTMLStencilElement {
    }
    var HTMLInputSwitchBasicElement: {
        prototype: HTMLInputSwitchBasicElement;
        new (): HTMLInputSwitchBasicElement;
    };
    interface HTMLInputSwitchDisabledElement extends Components.InputSwitchDisabled, HTMLStencilElement {
    }
    var HTMLInputSwitchDisabledElement: {
        prototype: HTMLInputSwitchDisabledElement;
        new (): HTMLInputSwitchDisabledElement;
    };
    interface HTMLInputSwitchPreselectionElement extends Components.InputSwitchPreselection, HTMLStencilElement {
    }
    var HTMLInputSwitchPreselectionElement: {
        prototype: HTMLInputSwitchPreselectionElement;
        new (): HTMLInputSwitchPreselectionElement;
    };
    interface HTMLInputTextBasicElement extends Components.InputTextBasic, HTMLStencilElement {
    }
    var HTMLInputTextBasicElement: {
        prototype: HTMLInputTextBasicElement;
        new (): HTMLInputTextBasicElement;
    };
    interface HTMLInputTextDisabledElement extends Components.InputTextDisabled, HTMLStencilElement {
    }
    var HTMLInputTextDisabledElement: {
        prototype: HTMLInputTextDisabledElement;
        new (): HTMLInputTextDisabledElement;
    };
    interface HTMLInputTextFloatLabelElement extends Components.InputTextFloatLabel, HTMLStencilElement {
    }
    var HTMLInputTextFloatLabelElement: {
        prototype: HTMLInputTextFloatLabelElement;
        new (): HTMLInputTextFloatLabelElement;
    };
    interface HTMLInputTextIconsElement extends Components.InputTextIcons, HTMLStencilElement {
    }
    var HTMLInputTextIconsElement: {
        prototype: HTMLInputTextIconsElement;
        new (): HTMLInputTextIconsElement;
    };
    interface HTMLElementTagNameMap {
        "any-badge": HTMLAnyBadgeElement;
        "any-badge-overlay": HTMLAnyBadgeOverlayElement;
        "any-button": HTMLAnyButtonElement;
        "any-checkbox": HTMLAnyCheckboxElement;
        "any-dropdown": HTMLAnyDropdownElement;
        "any-input-number": HTMLAnyInputNumberElement;
        "any-input-switch": HTMLAnyInputSwitchElement;
        "any-input-text": HTMLAnyInputTextElement;
        "any-input-textarea": HTMLAnyInputTextareaElement;
        "any-listbox": HTMLAnyListboxElement;
        "any-multiselect": HTMLAnyMultiselectElement;
        "any-overlay": HTMLAnyOverlayElement;
        "any-radio-button": HTMLAnyRadioButtonElement;
        "any-radio-group": HTMLAnyRadioGroupElement;
        "any-ripple-effect": HTMLAnyRippleEffectElement;
        "any-tab-panel": HTMLAnyTabPanelElement;
        "any-tab-view": HTMLAnyTabViewElement;
        "any-virtual-scroller": HTMLAnyVirtualScrollerElement;
        "app-code": HTMLAppCodeElement;
        "app-config": HTMLAppConfigElement;
        "app-doc": HTMLAppDocElement;
        "app-docapisection": HTMLAppDocapisectionElement;
        "app-docapitable": HTMLAppDocapitableElement;
        "app-docsection": HTMLAppDocsectionElement;
        "app-docsection-nav": HTMLAppDocsectionNavElement;
        "app-docsectiontext": HTMLAppDocsectiontextElement;
        "checkbox-basic": HTMLCheckboxBasicElement;
        "checkbox-disabled": HTMLCheckboxDisabledElement;
        "checkbox-dynamic": HTMLCheckboxDynamicElement;
        "checkbox-group": HTMLCheckboxGroupElement;
        "checkbox-label": HTMLCheckboxLabelElement;
        "checkbox-readonly": HTMLCheckboxReadonlyElement;
        "dropdown-basic": HTMLDropdownBasicElement;
        "dropdown-disabled": HTMLDropdownDisabledElement;
        "dropdown-filter": HTMLDropdownFilterElement;
        "dropdown-template": HTMLDropdownTemplateElement;
        "dropdown-virtual-scroll": HTMLDropdownVirtualScrollElement;
        "input-switch-basic": HTMLInputSwitchBasicElement;
        "input-switch-disabled": HTMLInputSwitchDisabledElement;
        "input-switch-preselection": HTMLInputSwitchPreselectionElement;
        "input-text-basic": HTMLInputTextBasicElement;
        "input-text-disabled": HTMLInputTextDisabledElement;
        "input-text-float-label": HTMLInputTextFloatLabelElement;
        "input-text-icons": HTMLInputTextIconsElement;
    }
}
declare namespace LocalJSX {
    interface AnyBadge {
        /**
          * Inline style of the component.
         */
        "anyStyle"?: any;
        /**
          * Severity type of the badge.
         */
        "severity"?: string;
        /**
          * Size of the badge, valid options are "large" and "xlarge".
         */
        "size"?: string;
        /**
          * Style class of the component.
         */
        "styleClass"?: string;
        /**
          * Value to display inside the badge.
         */
        "value"?: string;
    }
    interface AnyBadgeOverlay {
        /**
          * Style class of the component.
         */
        "styleClass"?: string;
    }
    interface AnyButton {
        /**
          * Inline style of the element.
         */
        "anyStyle"?: any;
        /**
          * Value of the badge.
         */
        "badge"?: string;
        /**
          * Style class of the badge.
         */
        "badgeClass"?: string;
        /**
          * When present, it specifies that the component should be disabled.
         */
        "disabled"?: boolean;
        /**
          * Name of the icon.
         */
        "icon"?: string;
        /**
          * Height of the icon
         */
        "iconHeight"?: number;
        /**
          * Position of the icon, valid values are "left" and "right".
         */
        "iconPos"?: "left" | "right" | "top" | "bottom";
        /**
          * Width of the icon
         */
        "iconWidth"?: number;
        /**
          * Text of the button.
         */
        "label"?: string;
        /**
          * Whether the button is in loading state.
         */
        "loading"?: boolean;
        /**
          * Icon to display in loading state.
         */
        "loadingIcon"?: string;
        /**
          * Style class of the icon element
         */
        "loadingIconStyleClass"?: string;
        /**
          * Callback to execute when button loses focus.
         */
        "onAOnBlur"?: (event: AnyButtonCustomEvent<any>) => void;
        /**
          * Callback to execute when button is clicked.
         */
        "onAOnClick"?: (event: AnyButtonCustomEvent<any>) => void;
        /**
          * Callback to execute when button is focused.
         */
        "onAOnFocus"?: (event: AnyButtonCustomEvent<any>) => void;
        /**
          * Style class of the element.
         */
        "styleClass"?: string;
        /**
          * Type of the button.
         */
        "type"?: "button" | "submit" | "reset";
    }
    /**
     * Checkbox is an extension to the standard checkbox element with theming.
     */
    interface AnyCheckbox {
        /**
          * Inline style of the component.
         */
        "anyStyle"?: any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * Allows to select a boolean value instead of multiple values.
         */
        "binary"?: boolean;
        /**
          * Icon class of the checkbox icon.
         */
        "checkboxIcon"?: string;
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled"?: boolean;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Label of the checkbox.
         */
        "label"?: string;
        /**
          * Style class of the label.
         */
        "labelStyleClass"?: string;
        /**
          * Name of the checkbox group.
         */
        "name"?: string;
        /**
          * Emitted when the toggle loses focus.
         */
        "onAOnBlur"?: (event: AnyCheckboxCustomEvent<any>) => void;
        /**
          * Emitted when the toggle has focus.
         */
        "onAOnFocus"?: (event: AnyCheckboxCustomEvent<any>) => void;
        /**
          * Callback to invoke when value of dropdown changes.
         */
        "onValueChange"?: (event: AnyCheckboxCustomEvent<any>) => void;
        /**
          * When present, it specifies that the component cannot be edited.
         */
        "readonly"?: boolean;
        /**
          * Style class of the component.
         */
        "styleClass"?: any;
        /**
          * The value of the checkbox does not mean if it's checked or not, use the `checked` property for that.  The value of a checkbox is analogous to the value of an `<input type="checkbox">`, it's only used when the checkbox participates in a native `<form>`.
         */
        "value"?: any;
    }
    /**
     * Dropdown, also known as Select, is used to choose an item from a collection of options.
     */
    interface AnyDropdown {
        /**
          * Inline style of the element.
         */
        "anyStyle"?: any;
        /**
          * Index of the element in tabbing order.
         */
        "anyTabIndex"?: number;
        /**
          * Whether to automatically manage layering.
         */
        "autoZIndex"?: boolean;
        /**
          * Base zIndex value to use in layering.
         */
        "baseZIndex"?: string;
        /**
          * Icon class of the dropdown clear icon.
         */
        "clearIcon"?: string;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled"?: boolean;
        /**
          * Icon class of the dropdown icon.
         */
        "dropdownIcon"?: string;
        /**
          * When specified, displays a filter input at header.
         */
        "filter"?: boolean;
        /**
          * Transition options of the hide animation.
         */
        "hideAnimation"?: string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Name of the dropdown input.
         */
        "name"?: string;
        /**
          * Callback to invoke when dropdown loses focus.
         */
        "onAOnBlur"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Callback to invoke when component is clicked.
         */
        "onAOnClick"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown gets focus.
         */
        "onAOnFocus"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay gets hidden.
         */
        "onAOnPanelHide"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay before gets hidden.
         */
        "onAOnPanelHideStart"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay gets visible.
         */
        "onAOnPanelShow"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay before gets visible.
         */
        "onAOnPanelShowStart"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Callback to invoke when value of dropdown changes.
         */
        "onValueChange"?: (event: AnyDropdownCustomEvent<any>) => void;
        /**
          * Name of the label field of an option
         */
        "optionLabel"?: string;
        /**
          * Name of the value field of an option.
         */
        "optionValue"?: string;
        /**
          * An array of objects to display as the available options.
         */
        "options"?: any[];
        /**
          * Height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value.
         */
        "panelScrollHeight"?: string;
        /**
          * Default text to display when no option is selected.
         */
        "placeholder"?: string;
        /**
          * When present, it specifies that the element value cannot be changed.
         */
        "readonly"?: boolean;
        /**
          * Keyframe name the show animation.
         */
        "showAnimation"?: string;
        /**
          * When enabled, a clear icon is displayed to clear the value.
         */
        "showClear"?: boolean;
        /**
          * Value of the dropdown list.
         */
        "value"?: any;
        /**
          * When present, list virtual scroller is enabled.
         */
        "virtualScroll"?: boolean;
    }
    interface AnyInputNumber {
        /**
          * Text to display before the value.
         */
        "aPrefix"?: string;
        /**
          * Text to display after the value.
         */
        "aSuffix"?: string;
        /**
          * Title text of the input text.
         */
        "aTitle"?: string;
        /**
          * Determines whether the input field is empty.
         */
        "allowEmpty"?: boolean;
        /**
          * Used to indicate that user input is required on an element before a form can be submitted.
         */
        "anyAriaRequired"?: boolean;
        /**
          * Inline style of the component.
         */
        "anyStyle"?: any;
        /**
          * Specifies tab order of the element.
         */
        "anyTabIndex"?: string;
        /**
          * Used to define a string that autocomplete attribute the current element.
         */
        "autocomplete"?: string;
        /**
          * Layout of the buttons, valid values are "stacked" (default), "horizontal" and "vertical".
         */
        "buttonLayout"?: string;
        /**
          * The currency to use in currency formatting. Possible values are the ISO 4217 currency codes(https://www.currency-iso.org/en/home/tables/table-a1.html), such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB. There is no default value; if the style is "currency", the currency property must be provided.
         */
        "currency"?: string;
        /**
          * How to display the currency in currency formatting. Possible values are "symbol" to use a localized currency symbol such as €, ü"code" to use the ISO currency code, "name" to use a localized currency name such as "dollar"; the default is "symbol".
         */
        "currencyDisplay"?: string;
        /**
          * Style class of the decrement button.
         */
        "decrementButtonClass"?: string;
        /**
          * Style class of the decrement button.
         */
        "decrementButtonIcon"?: string;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled"?: boolean;
        /**
          * Whether to format the value.
         */
        "format"?: boolean;
        /**
          * Style class of the increment button.
         */
        "incrementButtonClass"?: string;
        /**
          * Style class of the increment button.
         */
        "incrementButtonIcon"?: string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Inline style of the input field.
         */
        "inputStyle"?: any;
        /**
          * Style class of the input field.
         */
        "inputStyleClass"?: string;
        /**
          * The class of input wrapper element
         */
        "inputWrapperClass"?: string;
        /**
          * Label of the component
         */
        "label"?: string;
        /**
          * Locale to be used in formatting.
         */
        "locale"?: string;
        /**
          * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit". See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation for details.
         */
        "localeMatcher"?: string;
        /**
          * Maximum boundary value.
         */
        "max"?: number;
        /**
          * The maximum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (https://www.currency-iso.org/en/home/tables/table-a1.html) (2 if the list doesn't provide that information).
         */
        "maxFractionDigits"?: number;
        /**
          * Maximum number of character allows in the input field.
         */
        "maxlength"?: number;
        /**
          * Mininum boundary value.
         */
        "min"?: number;
        /**
          * The minimum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (https://www.currency-iso.org/en/home/tables/table-a1.html) (2 if the list doesn't provide that information).
         */
        "minFractionDigits"?: number;
        /**
          * Defines the behavior of the component, valid values are "decimal" and "currency".
         */
        "mode"?: string;
        /**
          * Name of the component
         */
        "name"?: string;
        /**
          * Callback to invoke when input loses focus.
         */
        "onAOnBlur"?: (event: AnyInputNumberCustomEvent<any>) => void;
        /**
          * Callback to invoke when input receives focus.
         */
        "onAOnFocus"?: (event: AnyInputNumberCustomEvent<any>) => void;
        /**
          * Callback to invoke when the value is entered.
         */
        "onAOnInput"?: (event: AnyInputNumberCustomEvent<any>) => void;
        /**
          * Callback to invoke when keyboard key is down.
         */
        "onAOnKeyDown"?: (event: AnyInputNumberCustomEvent<any>) => void;
        /**
          * Callback to invoke when value of componnt changes
         */
        "onValueChange"?: (event: AnyInputNumberCustomEvent<any>) => void;
        /**
          * Advisory information to display on input.
         */
        "placeholder"?: string;
        /**
          * When present, it specifies that an input field is read-only.
         */
        "readonly"?: boolean;
        /**
          * When present, it specifies that an input field is required.
         */
        "required"?: boolean;
        /**
          * Displays spinner buttons.
         */
        "showButtons"?: boolean;
        /**
          * Size of the input field.
         */
        "size"?: number;
        /**
          * Step factor to increment/decrement the value.
         */
        "step"?: number;
        /**
          * Style class of the component.
         */
        "styleClass"?: string;
        /**
          * Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.
         */
        "useGrouping"?: boolean;
        /**
          * Value of the component.
         */
        "value"?: string;
    }
    /**
     * InputSwitch is used to select a boolean value.
     */
    interface AnyInputSwitch {
        /**
          * Inline style of the component.
         */
        "anyStyle"?: any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
         */
        "ariaLabeledBy"?: string;
        /**
          * If `true`, the input-switch is selected.
         */
        "checked"?: boolean;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled"?: boolean;
        /**
          * Value in unchecked state.
         */
        "falseValue"?: any;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Name of the checkbox group.
         */
        "name"?: string;
        /**
          * Emitted when the toggle loses focus.
         */
        "onAOnBlur"?: (event: AnyInputSwitchCustomEvent<any>) => void;
        /**
          * Emitted when the toggle has focus.
         */
        "onAOnFocus"?: (event: AnyInputSwitchCustomEvent<any>) => void;
        /**
          * Callback to invoke when value of dropdown changes.
         */
        "onValueChange"?: (event: AnyInputSwitchCustomEvent<any>) => void;
        /**
          * When present, it specifies that the component cannot be edited.
         */
        "readonly"?: boolean;
        /**
          * Style class of the component.
         */
        "styleClass"?: any;
        /**
          * Value in checked state.
         */
        "trueValue"?: any;
    }
    /**
     * The InputText component is a wrapper to the HTML input element with custom styling and additional
     * functionality.
     */
    interface AnyInputText {
        /**
          * Title text of the input text.
         */
        "aTitle"?: string;
        /**
          * Used to indicate that user input is required on an element before a form can be submitted.
         */
        "anyAriaRequired"?: boolean;
        /**
          * Specifies tab order of the element.
         */
        "anyTabIndex"?: string;
        /**
          * Used to define a string that autocomplete attribute the current element.
         */
        "autocomplete"?: string;
        /**
          * When present, it specifies that the element should be disabled
         */
        "disabled"?: boolean;
        /**
          * When enabled, the label will have floating effect on input text focus
         */
        "floatLabel"?: boolean;
        /**
          * Inline style of the element
         */
        "inputClass"?: string;
        /**
          * The class of input holder element
         */
        "inputHolderClass"?: string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Inline style of the element
         */
        "inputStyle"?: any;
        /**
          * The class of input wrapper element
         */
        "inputWrapperClass"?: string;
        /**
          * Label of the input text
         */
        "label"?: string;
        /**
          * The class of left icon wrapper element
         */
        "leftIconClass"?: string;
        /**
          * Maximum number of character allows in the input field.
         */
        "maxlength"?: number;
        /**
          * Name of the input text.
         */
        "name"?: string;
        /**
          * Callback to invoke when value of input text changes
         */
        "onValueChange"?: (event: AnyInputTextCustomEvent<any>) => void;
        /**
          * Default text to display when no value in input text
         */
        "placeholder"?: string;
        /**
          * When present, it specifies that the element value cannot be changed
         */
        "readonly"?: boolean;
        /**
          * When present, it specifies that an input field is required.
         */
        "required"?: boolean;
        /**
          * The class of right icon wrapper element
         */
        "rightIconClass"?: string;
        /**
          * Size of the input field.
         */
        "size"?: number;
        /**
          * Value of the input text
         */
        "value"?: string;
    }
    interface AnyInputTextarea {
        /**
          * When present, textarea size changes as being typed.
         */
        "autoResize"?: boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled"?: boolean;
        /**
          * When enabled, the label will have floating effect on input text focus
         */
        "floatLabel"?: boolean;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * The class of input wrapper element
         */
        "inputWrapperClass"?: string;
        /**
          * Label of the input text
         */
        "label"?: string;
        /**
          * Name of the input text.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onAOnBlur"?: (event: AnyInputTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onAOnFocus"?: (event: AnyInputTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onAOnInput"?: (event: AnyInputTextareaCustomEvent<InputEvent>) => void;
        /**
          * Emitted when the input has resized.
         */
        "onAOnResize"?: (event: AnyInputTextareaCustomEvent<any>) => void;
        /**
          * Emitted when the input value has changed.
         */
        "onValueChange"?: (event: AnyInputTextareaCustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Default text to display when no value in input textarea
         */
        "placeholder"?: string;
        /**
          * When present, it specifies that the element value cannot be changed
         */
        "readonly"?: boolean;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: "hard" | "soft" | "off";
    }
    interface AnyListbox {
        /**
          * Inline style of the element.
         */
        "anyStyle"?: any;
        /**
          * When specified, allows selecting items with checkboxes.
         */
        "checkbox"?: boolean;
        /**
          * A property to uniquely identify a value in options.
         */
        "dataKey"?: string;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled"?: boolean;
        /**
          * Text to display when filtering does not return any results. Defaults to global value in i18n translation configuration.
         */
        "emptyFilterMessage"?: string;
        /**
          * Text to display when there is no data. Defaults to global value in i18n translation configuration.
         */
        "emptyMessage"?: string;
        /**
          * When specified, displays a filter input at header.
         */
        "filter"?: boolean;
        /**
          * When filtering is enabled, filterBy decides which field or fields (comma separated) to search against.
         */
        "filterBy"?: string;
        /**
          * Locale to use in filtering. The default locale is the host environment's current locale.
         */
        "filterLocale"?: string;
        /**
          * Defines how the items are filtered, valid values are "contains" (default) "startsWith", "endsWith", "equals", "notEquals", "in", "lt", "lte", "gt" and "gte".
         */
        "filterMatchMode"?: string;
        /**
          * When specified, filter displays with this value.
         */
        "filterValue"?: string;
        /**
          * Whether to display options as grouped when nested options are provided.
         */
        "group"?: boolean;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Inline style of the list element.
         */
        "listStyle"?: any;
        /**
          * Defines how multiple items can be selected, when true metaKey needs to be pressed to select or unselect an item and when set to false selection of each item can be toggled individually. On touch enabled devices, metaKeySelection is turned off automatically.
         */
        "metaKeySelection"?: boolean;
        /**
          * When specified, allows selecting multiple values.
         */
        "multiple"?: boolean;
        /**
          * Name of the dropdown input.
         */
        "name"?: string;
        /**
          * Callback to invoke when value of listbox changes
         */
        "onValueChange"?: (event: AnyListboxCustomEvent<SelectChangeEventDetail>) => void;
        /**
          * Name of the disabled field of an option.
         */
        "optionDisabled"?: string;
        /**
          * Name of the options field of an option group.
         */
        "optionGroupChildren"?: string;
        /**
          * Name of the label field of an option.
         */
        "optionLabel"?: string;
        /**
          * Name of the value field of an option.
         */
        "optionValue"?: string;
        /**
          * An array of objects to display as the available options.
         */
        "options"?: any[];
        /**
          * When present, it specifies that the element value cannot be changed.
         */
        "readonly"?: boolean;
        /**
          * Max height of the content area in inline mode.
         */
        "scrollerHeight"?: string;
        /**
          * Icon class of the filter search input icon.
         */
        "searchIcon"?: string;
        /**
          * Whether header checkbox is shown in multiple mode.
         */
        "showToggleAll"?: boolean;
        /**
          * Value of the listbox.
         */
        "value"?: any;
        /**
          * When present, list virtual scroller is enabled.
         */
        "virtualScroll"?: boolean;
    }
    interface AnyMultiselect {
        /**
          * Inline style of the element
         */
        "anyStyle"?: any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * When specified, allows selecting items with checkboxes
         */
        "checkbox"?: boolean;
        /**
          * Icon class of the dropdown clear icon
         */
        "clearIcon"?: string;
        /**
          * A property to uniquely identify a value in options
         */
        "dataKey"?: string;
        /**
          * When specified, allows selecting items with checkboxes
         */
        "defaultLabel"?: string;
        /**
          * When present, it specifies that the element should be disabled
         */
        "disabled"?: boolean;
        /**
          * Icon class of the dropdown icon
         */
        "dropdownIcon"?: string;
        /**
          * When specified, displays a filter input at header
         */
        "filter"?: boolean;
        /**
          * Whether to display options as grouped when nested options are provided
         */
        "group"?: boolean;
        /**
          * Transition options for the hide animation.
         */
        "hideAnimation"?: string;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Name of the dropdown input.
         */
        "name"?: string;
        /**
          * Callback to invoke when dropdown loses focus
         */
        "onAOnBlur"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Callback to invoke when component is clicked
         */
        "onAOnClick"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown gets focus
         */
        "onAOnFocus"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay gets hidden
         */
        "onAOnPanelHide"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay before gets hidden
         */
        "onAOnPanelHideStart"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay gets visible
         */
        "onAOnPanelShow"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Callback to invoke when dropdown overlay before gets visible
         */
        "onAOnPanelShowStart"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Callback to invoke when value of dropdown changes
         */
        "onValueChange"?: (event: AnyMultiselectCustomEvent<any>) => void;
        /**
          * Name of the options field of an option group.
         */
        "optionGroupChildren"?: string;
        /**
          * Name of the label field of an option
         */
        "optionLabel"?: string;
        /**
          * Name of the value field of an option
         */
        "optionValue"?: string;
        /**
          * An array of objects to display as the available options.
         */
        "options"?: any[];
        /**
          * Height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value
         */
        "panelScrollHeight"?: string;
        /**
          * Default text to display when no option is selected
         */
        "placeholder"?: string;
        /**
          * When present, it specifies that the element value cannot be changed
         */
        "readonly"?: boolean;
        /**
          * Keyframe name for the show animation.
         */
        "showAnimation"?: string;
        /**
          * When enabled, a clear icon is displayed to clear the value
         */
        "showClear"?: boolean;
        /**
          * Whether header checkbox is shown in multiple mode
         */
        "showToggleAll"?: boolean;
        /**
          * Value of the dropdown list
         */
        "value"?: any;
        /**
          * When present, list virtual scroller is enabled
         */
        "virtualScroll"?: boolean;
    }
    interface AnyOverlay {
        /**
          * Whether to automatically manage layering
         */
        "autoZIndex"?: boolean;
        /**
          * Base zIndex value to use in layering
         */
        "baseZIndex"?: string;
        /**
          * Transition options for the hide animation.
         */
        "hideAnimation"?: string;
        /**
          * Callback to invoke when the dropdown overlay becomes hidden.
         */
        "onAOnHide"?: (event: AnyOverlayCustomEvent<any>) => void;
        /**
          * Callback to invoke when the dropdown overlay is about to become hidden.
         */
        "onAOnHideStart"?: (event: AnyOverlayCustomEvent<any>) => void;
        /**
          * Callback to invoke when the dropdown overlay becomes visible.
         */
        "onAOnShow"?: (event: AnyOverlayCustomEvent<any>) => void;
        /**
          * Callback to invoke when the dropdown overlay is about to become visible.
         */
        "onAOnShowStart"?: (event: AnyOverlayCustomEvent<any>) => void;
        /**
          * Keyframe name for the show animation.
         */
        "showAnimation"?: string;
        /**
          * The target element to attach the dropdown to.
         */
        "target"?: any;
        /**
          * Whether the dropdown is currently visible or hidden.
         */
        "visible"?: boolean;
    }
    interface AnyRadioButton {
        /**
          * Inline style of the component.
         */
        "anyStyle"?: any;
        /**
          * Index of the element in tabbing order
         */
        "anyTabIndex"?: number;
        /**
          * When present, it specifies that the element should be disabled.
         */
        "disabled"?: boolean;
        /**
          * Identifier of the focus input to match a label defined for the component.
         */
        "inputId"?: string;
        /**
          * Label of the radiobutton.
         */
        "label"?: string;
        /**
          * Style class of the label.
         */
        "labelStyleClass"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Callback to invoke when the radio button loses focus.
         */
        "onAOnBlur"?: (event: AnyRadioButtonCustomEvent<any>) => void;
        /**
          * Callback to invoke when the radio button receives focus.
         */
        "onAOnFocus"?: (event: AnyRadioButtonCustomEvent<any>) => void;
        /**
          * Callback to invoke on radio button select.
         */
        "onAOnSelect"?: (event: AnyRadioButtonCustomEvent<any>) => void;
        /**
          * Style class of the component.
         */
        "styleClass"?: any;
        /**
          * the value of the radio.
         */
        "value"?: any | null;
    }
    interface AnyRadioGroup {
        /**
          * If `true`, the radios can be deselected.
         */
        "allowEmptySelection"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the value has changed.
         */
        "onValueChange"?: (event: AnyRadioGroupCustomEvent<RadioGroupChangeEventDetail>) => void;
        /**
          * the value of the radio group.
         */
        "value"?: any | null;
    }
    interface AnyRippleEffect {
        /**
          * Inline style of the component.
         */
        "anyStyle"?: any;
        /**
          * Sets the type of ripple-effect:
         */
        "type"?: "bounded" | "unbounded";
    }
    interface AnyTabPanel {
        /**
          * When true, tab cannot be activated.
         */
        "disabled"?: boolean;
        /**
          * Title of the tabPanel.
         */
        "header"?: string;
        /**
          * Defines if tab is active.
         */
        "selected"?: boolean;
    }
    interface AnyTabView {
        /**
          * Index of the active tab to change selected tab programmatically.
         */
        "activeIndex"?: number;
        /**
          * Inline style of the component.
         */
        "anyStyle"?: any;
        /**
          * Style class of the component.
         */
        "styleClass"?: string;
    }
    interface AnyVirtualScroller {
        /**
          * Inline style of the component
         */
        "anyStyle"?: any;
        /**
          * Class name of the content element where items will be rendered
         */
        "contentElemClass"?: string;
        /**
          * Tag name of content element whwre items will be rendered
         */
        "contentElemTag"?: string;
        /**
          * Threshold in milliseconds to delay lazy loading during scrolling
         */
        "delay"?: number;
        /**
          * Class name of the item element
         */
        "itemElemClass"?: string;
        /**
          * Height of an item in the list
         */
        "itemSize"?: number;
        /**
          * Tag name for supporting elements: spacing extra rows, empty-data row. It will be determined by itself once data provided, so it's optional. But if your data is not provided during initialization - it is better to specify this option because otherwise plugin will be unable to correctly render empty-data row.
         */
        "itemTag"?: string;
        /**
          * An array of objects to display
         */
        "items"?: any[];
        /**
          * Defines if data is loaded and interacted with in lazy manner
         */
        "lazy"?: boolean;
        /**
          * Text for placeholder element if there is no data provided
         */
        "noDataText"?: string;
        /**
          * Callback when item is clicked
         */
        "onAOnItemClick"?: (event: AnyVirtualScrollerCustomEvent<any>) => void;
        /**
          * Callback to invoke in lazy mode to load new data
         */
        "onAOnLazyLoad"?: (event: AnyVirtualScrollerCustomEvent<any>) => void;
        /**
          * Will be called right after replacing previous cluster with new one
         */
        "onClusterChanged"?: (event: AnyVirtualScrollerCustomEvent<any>) => void;
        /**
          * Will be called right before replacing previous cluster with new one
         */
        "onClusterWillChange"?: (event: AnyVirtualScrollerCustomEvent<any>) => void;
        /**
          * Will be called on scrolling. Returns progress position
         */
        "onScrollingProgress"?: (event: AnyVirtualScrollerCustomEvent<any>) => void;
        /**
          * Number of rows to display per page
         */
        "rowsPerPage"?: number;
        /**
          * Class name of the scroll element
         */
        "scrollElemClass"?: string;
        /**
          * Max height of the content area in inline mode
         */
        "scrollerHeight"?: any;
        /**
          * Inline style of the component
         */
        "styleClass"?: string;
    }
    interface AppCode {
        "code": any;
        "extFiles"?: any[];
        "hideCodeSandbox"?: boolean;
        "hideStackBlitz"?: boolean;
        "hideToggleCode"?: boolean;
        "routeFiles"?: any[];
        "selector": string;
        "service"?: any;
    }
    interface AppConfig {
    }
    interface AppDoc {
        "apiDocs": string[];
        "description": string;
        "docTitle"?: string;
        "docs": any[];
        "githubPage": string;
        "header": string;
    }
    interface AppDocapisection {
        "docs"?: any;
        "header"?: string;
    }
    interface AppDocapitable {
        "anyId"?: string;
        "data"?: any[];
        "description"?: string;
        "isInterface"?: boolean;
        "label"?: string;
        "level"?: number;
        "parentDescription"?: string;
        "parentId"?: string;
        "parentTitle"?: string;
        "relatedProp"?: string;
    }
    interface AppDocsection {
        "apiDocs"?: any[];
        "docs"?: any[];
    }
    interface AppDocsectionNav {
        "docs": any[];
    }
    interface AppDocsectiontext {
        "label"?: string;
        "level"?: number;
        "parentDescription"?: string;
        "parentId"?: string;
        "parentTitle"?: string;
        "textId"?: string;
        "textTitle"?: string;
    }
    interface CheckboxBasic {
        "onValueChange"?: (event: CheckboxBasicCustomEvent<boolean>) => void;
        "textId"?: string;
        "textTitle"?: string;
    }
    interface CheckboxDisabled {
        "onValueChange"?: (event: CheckboxDisabledCustomEvent<boolean>) => void;
        "textId"?: string;
        "textTitle"?: string;
    }
    interface CheckboxDynamic {
        "onValueChange"?: (event: CheckboxDynamicCustomEvent<boolean>) => void;
        "textId"?: string;
        "textTitle"?: string;
    }
    interface CheckboxGroup {
        "onValueChange"?: (event: CheckboxGroupCustomEvent<boolean>) => void;
        "textId"?: string;
        "textTitle"?: string;
    }
    interface CheckboxLabel {
        "onValueChange"?: (event: CheckboxLabelCustomEvent<boolean>) => void;
        "textId"?: string;
        "textTitle"?: string;
    }
    interface CheckboxReadonly {
        "onValueChange"?: (event: CheckboxReadonlyCustomEvent<boolean>) => void;
        "textId"?: string;
        "textTitle"?: string;
    }
    interface DropdownBasic {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface DropdownDisabled {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface DropdownFilter {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface DropdownTemplate {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface DropdownVirtualScroll {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface InputSwitchBasic {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface InputSwitchDisabled {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface InputSwitchPreselection {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface InputTextBasic {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface InputTextDisabled {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface InputTextFloatLabel {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface InputTextIcons {
        "textId"?: string;
        "textTitle"?: string;
    }
    interface IntrinsicElements {
        "any-badge": AnyBadge;
        "any-badge-overlay": AnyBadgeOverlay;
        "any-button": AnyButton;
        "any-checkbox": AnyCheckbox;
        "any-dropdown": AnyDropdown;
        "any-input-number": AnyInputNumber;
        "any-input-switch": AnyInputSwitch;
        "any-input-text": AnyInputText;
        "any-input-textarea": AnyInputTextarea;
        "any-listbox": AnyListbox;
        "any-multiselect": AnyMultiselect;
        "any-overlay": AnyOverlay;
        "any-radio-button": AnyRadioButton;
        "any-radio-group": AnyRadioGroup;
        "any-ripple-effect": AnyRippleEffect;
        "any-tab-panel": AnyTabPanel;
        "any-tab-view": AnyTabView;
        "any-virtual-scroller": AnyVirtualScroller;
        "app-code": AppCode;
        "app-config": AppConfig;
        "app-doc": AppDoc;
        "app-docapisection": AppDocapisection;
        "app-docapitable": AppDocapitable;
        "app-docsection": AppDocsection;
        "app-docsection-nav": AppDocsectionNav;
        "app-docsectiontext": AppDocsectiontext;
        "checkbox-basic": CheckboxBasic;
        "checkbox-disabled": CheckboxDisabled;
        "checkbox-dynamic": CheckboxDynamic;
        "checkbox-group": CheckboxGroup;
        "checkbox-label": CheckboxLabel;
        "checkbox-readonly": CheckboxReadonly;
        "dropdown-basic": DropdownBasic;
        "dropdown-disabled": DropdownDisabled;
        "dropdown-filter": DropdownFilter;
        "dropdown-template": DropdownTemplate;
        "dropdown-virtual-scroll": DropdownVirtualScroll;
        "input-switch-basic": InputSwitchBasic;
        "input-switch-disabled": InputSwitchDisabled;
        "input-switch-preselection": InputSwitchPreselection;
        "input-text-basic": InputTextBasic;
        "input-text-disabled": InputTextDisabled;
        "input-text-float-label": InputTextFloatLabel;
        "input-text-icons": InputTextIcons;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "any-badge": LocalJSX.AnyBadge & JSXBase.HTMLAttributes<HTMLAnyBadgeElement>;
            "any-badge-overlay": LocalJSX.AnyBadgeOverlay & JSXBase.HTMLAttributes<HTMLAnyBadgeOverlayElement>;
            "any-button": LocalJSX.AnyButton & JSXBase.HTMLAttributes<HTMLAnyButtonElement>;
            /**
             * Checkbox is an extension to the standard checkbox element with theming.
             */
            "any-checkbox": LocalJSX.AnyCheckbox & JSXBase.HTMLAttributes<HTMLAnyCheckboxElement>;
            /**
             * Dropdown, also known as Select, is used to choose an item from a collection of options.
             */
            "any-dropdown": LocalJSX.AnyDropdown & JSXBase.HTMLAttributes<HTMLAnyDropdownElement>;
            "any-input-number": LocalJSX.AnyInputNumber & JSXBase.HTMLAttributes<HTMLAnyInputNumberElement>;
            /**
             * InputSwitch is used to select a boolean value.
             */
            "any-input-switch": LocalJSX.AnyInputSwitch & JSXBase.HTMLAttributes<HTMLAnyInputSwitchElement>;
            /**
             * The InputText component is a wrapper to the HTML input element with custom styling and additional
             * functionality.
             */
            "any-input-text": LocalJSX.AnyInputText & JSXBase.HTMLAttributes<HTMLAnyInputTextElement>;
            "any-input-textarea": LocalJSX.AnyInputTextarea & JSXBase.HTMLAttributes<HTMLAnyInputTextareaElement>;
            "any-listbox": LocalJSX.AnyListbox & JSXBase.HTMLAttributes<HTMLAnyListboxElement>;
            "any-multiselect": LocalJSX.AnyMultiselect & JSXBase.HTMLAttributes<HTMLAnyMultiselectElement>;
            "any-overlay": LocalJSX.AnyOverlay & JSXBase.HTMLAttributes<HTMLAnyOverlayElement>;
            "any-radio-button": LocalJSX.AnyRadioButton & JSXBase.HTMLAttributes<HTMLAnyRadioButtonElement>;
            "any-radio-group": LocalJSX.AnyRadioGroup & JSXBase.HTMLAttributes<HTMLAnyRadioGroupElement>;
            "any-ripple-effect": LocalJSX.AnyRippleEffect & JSXBase.HTMLAttributes<HTMLAnyRippleEffectElement>;
            "any-tab-panel": LocalJSX.AnyTabPanel & JSXBase.HTMLAttributes<HTMLAnyTabPanelElement>;
            "any-tab-view": LocalJSX.AnyTabView & JSXBase.HTMLAttributes<HTMLAnyTabViewElement>;
            "any-virtual-scroller": LocalJSX.AnyVirtualScroller & JSXBase.HTMLAttributes<HTMLAnyVirtualScrollerElement>;
            "app-code": LocalJSX.AppCode & JSXBase.HTMLAttributes<HTMLAppCodeElement>;
            "app-config": LocalJSX.AppConfig & JSXBase.HTMLAttributes<HTMLAppConfigElement>;
            "app-doc": LocalJSX.AppDoc & JSXBase.HTMLAttributes<HTMLAppDocElement>;
            "app-docapisection": LocalJSX.AppDocapisection & JSXBase.HTMLAttributes<HTMLAppDocapisectionElement>;
            "app-docapitable": LocalJSX.AppDocapitable & JSXBase.HTMLAttributes<HTMLAppDocapitableElement>;
            "app-docsection": LocalJSX.AppDocsection & JSXBase.HTMLAttributes<HTMLAppDocsectionElement>;
            "app-docsection-nav": LocalJSX.AppDocsectionNav & JSXBase.HTMLAttributes<HTMLAppDocsectionNavElement>;
            "app-docsectiontext": LocalJSX.AppDocsectiontext & JSXBase.HTMLAttributes<HTMLAppDocsectiontextElement>;
            "checkbox-basic": LocalJSX.CheckboxBasic & JSXBase.HTMLAttributes<HTMLCheckboxBasicElement>;
            "checkbox-disabled": LocalJSX.CheckboxDisabled & JSXBase.HTMLAttributes<HTMLCheckboxDisabledElement>;
            "checkbox-dynamic": LocalJSX.CheckboxDynamic & JSXBase.HTMLAttributes<HTMLCheckboxDynamicElement>;
            "checkbox-group": LocalJSX.CheckboxGroup & JSXBase.HTMLAttributes<HTMLCheckboxGroupElement>;
            "checkbox-label": LocalJSX.CheckboxLabel & JSXBase.HTMLAttributes<HTMLCheckboxLabelElement>;
            "checkbox-readonly": LocalJSX.CheckboxReadonly & JSXBase.HTMLAttributes<HTMLCheckboxReadonlyElement>;
            "dropdown-basic": LocalJSX.DropdownBasic & JSXBase.HTMLAttributes<HTMLDropdownBasicElement>;
            "dropdown-disabled": LocalJSX.DropdownDisabled & JSXBase.HTMLAttributes<HTMLDropdownDisabledElement>;
            "dropdown-filter": LocalJSX.DropdownFilter & JSXBase.HTMLAttributes<HTMLDropdownFilterElement>;
            "dropdown-template": LocalJSX.DropdownTemplate & JSXBase.HTMLAttributes<HTMLDropdownTemplateElement>;
            "dropdown-virtual-scroll": LocalJSX.DropdownVirtualScroll & JSXBase.HTMLAttributes<HTMLDropdownVirtualScrollElement>;
            "input-switch-basic": LocalJSX.InputSwitchBasic & JSXBase.HTMLAttributes<HTMLInputSwitchBasicElement>;
            "input-switch-disabled": LocalJSX.InputSwitchDisabled & JSXBase.HTMLAttributes<HTMLInputSwitchDisabledElement>;
            "input-switch-preselection": LocalJSX.InputSwitchPreselection & JSXBase.HTMLAttributes<HTMLInputSwitchPreselectionElement>;
            "input-text-basic": LocalJSX.InputTextBasic & JSXBase.HTMLAttributes<HTMLInputTextBasicElement>;
            "input-text-disabled": LocalJSX.InputTextDisabled & JSXBase.HTMLAttributes<HTMLInputTextDisabledElement>;
            "input-text-float-label": LocalJSX.InputTextFloatLabel & JSXBase.HTMLAttributes<HTMLInputTextFloatLabelElement>;
            "input-text-icons": LocalJSX.InputTextIcons & JSXBase.HTMLAttributes<HTMLInputTextIconsElement>;
        }
    }
}
